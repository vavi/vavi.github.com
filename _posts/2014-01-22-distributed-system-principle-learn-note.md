---
layout: post
title: "分布式存储系统概述"
description: ""
category: 分布式系统
tags: [分布式系统]
---
 
## 基础概念
### 网络调用3态
网络RPC调用3种结果：成功，失败，超时。一旦发生超时后，无法确认是否调用成功。
### CAP 
CAP是指
一致性：读操作总是能够读取之前完成的写操作结果，满足这个条件我们称之为强一致性系统
可用性：读写操作单台机器发生故障的情况下仍然能够正常执行，不需要等待发生故障的机器重启或者该机器上面的服务前移到其他机器
分区可容忍性：机器故障，网络故障，机房停电等异常情况下仍然满足一致性和可用性。

CAP 理论的定义很简单，CAP 三个字母分别代表了分布式系统中三个相互矛盾的属性： 
Consistency (一致性)：CAP 理论中的副本一致性特指强一致性（1.3.4  ）；  
Availiablity(可用性)：指系统在出现异常时已经可以提供服务； 
Tolerance to the partition of network (分区容忍)：指系统可以对网络分区（1.1.4.2  ）这种异常情
况进行容错处理； 
CAP 理论指出：无法设计一种分布式协议，使得同时完全具备 CAP 三个属性，即 1)该种协议
下的副本始终是强一致性，2)服务始终是可用的，3)协议可以容忍任何网络分区异常；分布式系统
协议只能在 CAP 这三者间所有折中。 




CAP 理论指出：无法设计一种分布式协议，使得同时完全具备 CAP 三个属性，即 1)该种协议
下的副本始终是强一致性，2)服务始终是可用的，3)协议可以容忍任何网络分区异常；分布式系统
协议只能在 CAP 这三者间所有折中。 

C 所有节点看到一致的数据 ，3个副本由2个写成功即可。 All or Nothing，or partcial???
 

虽然不是一个层面上的概念，但是这里也要把ACID拿出来复习下。
ACID，Atomic，Consistent，Isolated，Durable

ACID的C不同于CAP中的C
http://zh.wikipedia.org/wiki/ACID

原子性，保证操作的逻辑，要么最终全部成功，要么最终全部失败。一致性约束可见性，要么看到的是事务处理前的状态，要么是处理完的状态，处理中的状态不可见。持久性就是事务结束后看到的状态，不可退回事务前的状态。 隔离性，与性能有关，影响到一致性保证的级别。 隔离性的概念一知半解，呵呵

原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的默认规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
隔离性：当两个或者多个事务并发访问（此处访问指查询和修改的操作）数据库的同一数据时所表现出的相互关系。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
持久性：在事务完成以后，该事务对数据库所作的更改便持久地保存在数据库之中，并且是完全的。

ACID 一致性  两个事务，一增一减  i 4个隔离级别 RU RC RR SR

base

TCC

### 副本一致性
副本指在分布式系统中为数据或者服务提供的冗余。副本一致性是针对分布式系统而言的。

备份和低一致性 来提升可用性和网络分区容忍性

强一致性 单调一致性  会话一致性  最终一致性 弱一致性 
节选自
强一致性(strong consistency)：任何时刻任何用户或节点都可以读到最近一次成功更新的副本数
据。强一致性是程度最高的一致性要求，也是实践中最难以实现的一致性。 
单调一致性(monotonic consistency)：任何时刻，任何用户一旦读到某个数据在某次更新后的值，
这个用户不会再读到比这个值更旧的值。单调一致性是弱于强一致性却非常实用的一种一致性级别。
因为通常来说，用户只关心从己方视角观察到的一致性，而不会关注其他用户的一致性情况。 
会话一致性(session consistency)：任何用户在某一次会话内一旦读到某个数据在某次更新后的值，
这个用户在这次会话过程中不会再读到比这个值更旧的值。会话一致性通过引入会话的概念，在单
调一致性的基础上进一步放松约束，会话一致性只保证单个用户单次会话内数据的单调修改，对于
不同用户间的一致性和同一用户不同会话间的一致性没有保障。实践中有许多机制正好对应会话的
概念，例如 php 中的 session 概念。可以将数据版本号等信息保存在 session 中，读取数据时验证副
本的版本号，只读取版本号大于等于 session 中版本号的副本，从而实现会话一致性。 
最终一致性(eventual consistency)：最终一致性要求一旦更新成功，各个副本上的数据最终将达
到完全一致的状态，但达到完全一致状态所需要的时间不能保障。对于最终一致性系统而言，一个
用户只要始终读取某一个副本的数据，则可以实现类似单调一致性的效果，但一旦用户更换读取的
副本，则无法保障任何一致性。 
弱一致性(week  consistency)：一旦某个更新成功，用户无法在一个确定时间内读到这次更新的
值，且即使在某个副本上读到了新的值，也不能保证在其他副本上可以读到新的值。弱一致性系统
一般很难在实际中使用，使用弱一致性系统需要应用方做更多的工作从而使得系统可用。 



### 副本控制协议
从上面引出副本一致性问题
 中心化副本控制协议
primary-secondary（也称primary-backup）。在该协议中，副本被分成两大类：primary副本，非primary副本，简称为secondary副本。维护primary副本的节点作为中心节点，中心节点负责维护数据的更新，并发控制和协调副本的一致性。

需要解决数据更新流程，数据读取流程，primary副本的确定和切换，数据同步。

* 外部节点把更新操作发给primary节点
* primary节点确定并发更新操作的先后顺序
* primary节点将更新操作发送给secondary节点
* primary节点根据secondary节点的完成情况决定更新操作是否成功，并将结果返回给外部节点。

如果由primary直接同时想其他N个副本的发送数据的话，那么每个secondar的更新吞吐受限于primary出口带宽的限制。所以，有些系统会使用副本接力的方式，比如primary发送个第一个secondary副本数据，第一个secondary副本发送第二个secondary数据，依次类推。

数据读取 由两种思路，随机确定primary副本，将数据分为数据段，以数据段为副本的基本单位，将副本分散到集群中。只要primary副本分散到集群中，即使只有primary副本提供读写服务，也可以充分利用集群机器资源。另一中思路就是主副本记录secondary是否可用。如果不可用，那么secondary副本可以继续尝试与primary副本同步数据，当完成数据同步时，primary副本将其标记位可用。

primary副本需要元数据服务器去维护。 存在如下问题，如何确定节点的状态以及发现原primary节点异常；切换primary后，不能影响副本一致性。 缺陷是，由于primary切换带来一定的停服时间。

数据同步存在3种情况：备副本完全落后主副本数据（新增副本节点），部分落后主副本数据（网络分化等原因），存在冗余副本数据（主副本没有更新，备副本反而进行了多余的修改操作）。3种解决方法 ：复制快照数据， 回放redo log，基于undo log 删除多余数据

副本复制分为两种，强同步复制和异步复制，两者的区别在于用户的请求是否在数据复制到其他副本上才返回成功。

一致性和可用性是矛盾的。强同步的问题的当备副本出现故障时，可能阻塞存储系统的正常写服务，可用性较差。异步复制协议的可用性较好，但是一致性得不到保障，主副本出现故障是还有数据丢失的可能。使用qurom 英 [ˈkwɔ:rəm]，法定人数。

复制概述：常见的做法是同步操作日志。主副本首先将操作日志同步到备副本，备副本回放操作日志，完成后通知主副本。接着，主副本修改本机，等到所有的操作都完成后再通知客户端写成功。

预写式日志（Write-ahead logging，缩写 WAL）通常包括redo和undo信息。根据数据重要级别，决定是否每次都将数据落盘。

checkpoint 系统定期将内存的操作以某种易于加载的形式（checkpoint文件）转存到磁盘中，并记录checkpoint时刻的日志回放点，以后故障恢复只需要回放checkpoint时刻之后的redo日志。


### 数据分布方式

hash 用户id的hash值 mod 服务器个数，缺点是扩展性差。一旦服务器个数变化，几乎所有数据需要被迁移并重新分布。可以增加中间层，即元数据服务器。需要防止数据倾斜问题。

还有两种，按数据范围分布和按数据量分布 。缺点都是元数据管理复杂。

一致性hash 通过引入虚节点的概念，虚节点的个数一般远大于未来集群中的机器数。首先根据数据的hash值找到虚节点，然后从元数据中找到真实节点。无论是增加节点还是节点宕机，都有助于实现全局负载均衡。

在存在多个副本的情况下，一般数据是以块的方式而不是机器的方式存放数据。这样便于在节点宕机后快速恢复数据以及负载均衡。

移动数据不如移动计算，本地化计算。

分库分表

wal vs redo 

数据分裂和合并。

----

## 分布式原理
### 一致性hash 
用于缓存和数据分区。 但是后者join 比较困难。 维护成本？

需要元数据服务器。或者

### 2阶段提交

两阶段提交：该协议通常用来实现分布式事务。系统一般包含两类节点：一类是协调者（coordinator），通常一个系统只有一个；另一类是事务参与者（participants），一般包含多个。协议中假设每个节点都会记录操作日志并持久化到非易失性存储介质。

它分成两个阶段，称之为准备阶段，提交阶段；也可以理解为投票，确认过程:

1. 准备阶段（Prepare Phrase）：
	* 协调者会问所有的参与者结点，是否可以执行提交操作。
	* 各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……。
	* 参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。
2. 确认阶段（Confirm Phrase）：
    * 如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。
    * 参与者完成正式提交，并释放所有资源，然后回应“完成”，
    * 协调者收集各结点的“完成”回应后结束这个Global Transaction。
	* 如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源.
	* 参与者然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。


异常流程的话，可以参考酷壳的这篇文章[分布式系统的事务处理](http://coolshell.cn/articles/10910.html)以及《分布式系统原理介绍》电子书的相应章节介绍。

### PAXOS

多个节点直接通过操作日志同步数据，如果只有一个节点称为主节点，就很容易在多个节点之间维护数据一致性。然后主节点可能出现故障，那么就需要选出主节点。Paxos协议就是用于解决多个节点之间的一致性问题。

PAXOS协议的角色分为 proposers，acceptors，和 learners（允许一个节点身兼数职）。proposers 提出提案，提案信息包括提案编号和提议的value；acceptor 收到提案后可以接受（accept）提案，若提案获得多数 acceptors 的接受，则称该提案被批准（chosen）；learners 只能「学习」被批准的提案。

通过一个决议分为两个阶段：

1. 准备阶段：
	* proposer选择一个提案序号n并将prepare 请求发送给其他acceptors ；
	* acceptor收到prepare消息后，如果提案的编号大于它已经回复的所有prepare消息，则acceptor将自己上次接受的提案回复给proposer，并承诺不再回复小于n的提案；
2. 批准阶段：
	* 当一个proposer收到了多数acceptors对prepare的回复后，就进入批准阶段。
	* 如果在之前的prepare阶段accptor回复了上次接受的提议，那么，proposer选择其中序号最大的提议值发送个acceptor批准
	* Acceptor在不违背自己向其他proposer的承诺的前提下，acceptor在收到accept请求后即接受这个请求。

在上述prepare过程中，如果一个acceptor发现存在一个更高编号的提案，则需要通知proposer，提醒其中断这次提案。

### 其他

* LEASE
，相当于租金，zk
的session 时间。

* MVCC:[多版本并发控制(MVCC)在分布式系统中的应用](http://coolshell.cn/articles/6790.html)
则使用copy-on-write来解决这个问题,cow+CAS+version

* NWR：2个苹果和3个梨放一个箱子。  dynamo 不好测试，对应用程序不友好，使用的业务场景有限。

数据分类：

* 非结构化数据：文本，图片，视频音频
* 结构化数据：数据模式（属性，数据类型，数据之间的联系）与内容是分开定义。
* 半结构化数据：模式和内容混在一起，没有明显的区分。
 

行式存储 
列式存储
 
  
配置统一管理

---

## 分布式存储系统

分布式存储系统通常需要解决如下一些问题
* 数据分布  在多台服务器之间保证数据分布均匀，跨服务器如何读写
* 一致性  异常情况下如何保证副本一致性
* 容错  把发生故障当成常态来设计，做到检测是否发生故障并进行故障迁移
* 负载均衡 新增、移除服务器时如何负载均衡 数据迁移如何不影响已有服务
* 事务并发控制  如何实现分布式事务，如何实现多版本并发控制
* 压缩、解压缩 根据数据特点选择恰当算法，如何平衡时间和空间的关系。

hostclass —》 host
 at least once，重发+唯一主键策略。
故障检测，Faliure  Detection

数据压缩 批处理

索引，耳机索引 

IOPS，即I/O per second，即每秒读写（I/O）操作的次数  http://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8A%A1%E5%86%85%E5%AD%98

事务内存目前有两种实现方式，基于软件的STM（Software Transactional Memory）和基于硬件的HTM（Hardware Transactional Memory）。 
 

单机 
多机
网络拓扑
协议定义
协议实现
google CLOS

log（事务id+动作+状态），然后基于log去推理，计算。对于单机事务可以基于wal（redo、undo）来恢复一致性。粗粒度的可以使用TCC服务。

元数据可以找服务器确定，也可以基于算法去确定。当主机宕机后，存在某个算法的下一个主机。当主机恢复启动时，可以问下我是否错过什么数据。如果错太远，错一点， 注意负载均衡 和网络带宽，磁盘io等。 主机节点的唯一性。

分布式存储的问题，尝试解答。
 
 
 redo undo 定期刷新
存储 分为 大文件，小文件，结构化，非结构化，分布式文件存储和数据库存储。数据库存储 读写分离，垂直扩展（scale up） 分表，水平扩展（scale out）分库， 

TDDL ， sql proxy、agent，binlog sync 分区分表 

存储    db,nosql,hbase, 分区表，字段压缩，查询优化，awr报告。

连接泄露原理是查询session视图，获得每个session的创建时间，看看那些session生命周期过长。然后找到对应执行的sql语句和业务代码。

略过，找到重要细节进行总结。从功能，适用场景，易用性，不断完善，

#### 分布式文件系统
适合存储blob对象。
一个大文件分成多个数据块（chunk），每个数据块大小相当。分布式文件系统将这些数据块分散到存储机器，并将用户对数据的操作转化为对若干个数据块的操作。

#### 分布式键值系统
基于主键实现CRUD功能，通常使用一致性hash技术。

#### 分布式表格系统
不仅仅支持基于主键的CURD操作，还支持扫描某个主键范围。一般仅支持单表操作。通常存储半结构化数据，不需要预先定义模式。

#### 分布式数据库
二维表格组织数据，支持sql，多表关联，嵌套子查询等复杂操作，并支持并发数据库事务。
### 重要细节
同一个数据中心延时较小，网络一次来回的时间在1毫秒之内。北京，杭州距离1300km，光在信息传输时走折线，假设折现距离是直线距离的1.5倍，那么整个耗时 1300*1.5*2/300000=13毫秒，实测时40毫秒。 

分布式存储系统 p10 性能参数 
亚马逊中文论文 ，中间件ali blog
google系列论文

和状态，每次事务开始，都必须记录日志。日志恢复时，根据交互多方所处的状态，决定是继续完成还是放弃完成。放弃后是否再次重试？ 

存在元数据的主节点记录业务状态 tcc（try，confirm，cancel）

csdn文章

---

## 参考

* 《深入分析Java Web 技术内幕》
* 《大规模分布式存储系统原理解析与架构实战》
* 《大型网站技术架构核心原理与案例分析》
* 《分布式系统原理介绍》
* 《大规模Web服务开发技术》
* 《面向模式的软件架构_第4卷_分布式计算的模式语言》
* 《程序员》 2014 第一期
*  [分布式系统的事务处理](http://coolshell.cn/articles/10910.html)
*  [Paxos算法](http://zh.wikipedia.org/zh/Paxos%E7%AE%97%E6%B3%95#.E5.AE.9E.E4.BE.8B)
*  [Explanation of BASE terminology](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)


{% include JB/setup %}
