---
layout: post
title: "分布式存储系统概述"
description: ""
category: 分布式系统
tags: [分布式系统]
---
 
## 分布式存储系统概述
### 基础概念
#### 网络调用3态
网络RPC调用3种结果：成功，失败，超时。一旦发生超时后，无法确认是否调用成功。
#### CAP 
CAP是指
一致性：读操作总是能够读取之前完成的写操作结果，满足这个条件我们称之为强一致性系统
可用性：读写操作单台机器发生故障的情况下仍然能够正常执行，不需要等待发生故障的机器重启或者该机器上面的服务前移到其他机器
分区可容忍性：机器故障，网络故障，机房停电等异常情况下仍然满足一致性和可用性。

CAP 理论指出：无法设计一种分布式协议，使得同时完全具备 CAP 三个属性，即 1)该种协议
下的副本始终是强一致性，2)服务始终是可用的，3)协议可以容忍任何网络分区异常；分布式系统
协议只能在 CAP 这三者间所有折中。 

C 所有节点看到一致的数据 ，3个副本由2个写成功即可。 All or Nothing，or partcial???
 

虽然不是一个层面上的概念，但是这里也要把ACID拿出来复习下。
ACID，Atomic，Consistent，Isolated，Durable

ACID的C不同于CAP中的C
http://zh.wikipedia.org/wiki/ACID

原子性，保证操作的逻辑，要么最终全部成功，要么最终全部失败。一致性约束可见性，要么看到的是事务处理前的状态，要么是处理完的状态，处理中的状态不可见。持久性就是事务结束后看到的状态，不可退回事务前的状态。 隔离性，与性能有关，影响到一致性保证的级别。 隔离性的概念一知半解，呵呵

原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的默认规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
隔离性：当两个或者多个事务并发访问（此处访问指查询和修改的操作）数据库的同一数据时所表现出的相互关系。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
持久性：在事务完成以后，该事务对数据库所作的更改便持久地保存在数据库之中，并且是完全的。

ACID 一致性  两个事务，一增一减  i 4个隔离级别 RU RC RR SR


#### 副本一致性
副本指在分布式系统中为数据或者服务提供的冗余。副本一致性是针对分布式系统而言的。

备份和低一致性 来提升可用性和网络分区容忍性

强一致性 单调一致性  会话一致性  最终一致性 弱一致性 
节选自
强一致性(strong consistency)：任何时刻任何用户或节点都可以读到最近一次成功更新的副本数
据。强一致性是程度最高的一致性要求，也是实践中最难以实现的一致性。 
单调一致性(monotonic consistency)：任何时刻，任何用户一旦读到某个数据在某次更新后的值，
这个用户不会再读到比这个值更旧的值。单调一致性是弱于强一致性却非常实用的一种一致性级别。
因为通常来说，用户只关心从己方视角观察到的一致性，而不会关注其他用户的一致性情况。 
会话一致性(session consistency)：任何用户在某一次会话内一旦读到某个数据在某次更新后的值，
这个用户在这次会话过程中不会再读到比这个值更旧的值。会话一致性通过引入会话的概念，在单
调一致性的基础上进一步放松约束，会话一致性只保证单个用户单次会话内数据的单调修改，对于
不同用户间的一致性和同一用户不同会话间的一致性没有保障。实践中有许多机制正好对应会话的
概念，例如 php 中的 session 概念。可以将数据版本号等信息保存在 session 中，读取数据时验证副
本的版本号，只读取版本号大于等于 session 中版本号的副本，从而实现会话一致性。 
最终一致性(eventual consistency)：最终一致性要求一旦更新成功，各个副本上的数据最终将达
到完全一致的状态，但达到完全一致状态所需要的时间不能保障。对于最终一致性系统而言，一个
用户只要始终读取某一个副本的数据，则可以实现类似单调一致性的效果，但一旦用户更换读取的
副本，则无法保障任何一致性。 
弱一致性(week  consistency)：一旦某个更新成功，用户无法在一个确定时间内读到这次更新的
值，且即使在某个副本上读到了新的值，也不能保证在其他副本上可以读到新的值。弱一致性系统
一般很难在实际中使用，使用弱一致性系统需要应用方做更多的工作从而使得系统可用。 



#### 副本控制协议
从上面引出副本一致性问题
 中心化副本控制协议
primary-secondary（也称primary-backup）。在该协议中，副本被分成两大类：primary副本，非primary副本，简称为secondary副本。维护primary副本的节点作为中心节点，中心节点负责维护数据的更新，并发控制和协调副本的一致性。

需要解决数据更新流程，数据读取流程，primary副本的确定和切换，数据同步。

* 外部节点把更新操作发给primary节点
* primary节点确定并发更新操作的先后顺序
* primary节点将更新操作发送给secondary节点
* primary节点根据secondary节点的完成情况决定更新操作是否成功，并将结果返回给外部节点。

如果由primary直接同时想其他N个副本的发送数据的话，那么每个secondar的更新吞吐受限于primary出口带宽的限制。所以，有些系统会使用副本接力的方式，比如primary发送个第一个secondary副本数据，第一个secondary副本发送第二个secondary数据，依次类推。

数据读取 由两种思路，随机确定primary副本，将数据分为数据段，以数据段为副本的基本单位，将副本分散到集群中。只要primary副本分散到集群中，即使只有primary副本提供读写服务，也可以充分利用集群机器资源。另一中思路就是主副本记录secondary是否可用。如果不可用，那么secondary副本可以继续尝试与primary副本同步数据，当完成数据同步时，primary副本将其标记位可用。

primary副本需要元数据服务器去维护。 存在如下问题，如何确定节点的状态以及发现原primary节点异常；切换primary后，不能影响副本一致性。 缺陷是，由于primary切换带来一定的停服时间。

数据同步存在3种情况：备副本完全落后主副本数据（新增副本节点），部分落后主副本数据（网络分化等原因），存在冗余副本数据（主副本没有更新，备副本反而进行了多余的修改操作）。3种解决方法 ：复制快照数据， 回放redo log，基于undo log 删除多余数据

副本复制分为两种，强同步复制和异步复制，两者的区别在于用户的请求是否在数据复制到其他副本上才返回成功。

一致性和可用性是矛盾的。强同步的问题的当备副本出现故障时，可能阻塞存储系统的正常写服务，可用性较差。异步复制协议的可用性较好，但是一致性得不到保障，主副本出现故障是还有数据丢失的可能。使用qurom 英 [ˈkwɔ:rəm]，法定人数。

复制概述：常见的做法是同步操作日志。主副本首先将操作日志同步到备副本，备副本回放操作日志，完成后通知主副本。接着，主副本修改本机，等到所有的操作都完成后再通知客户端写成功。

预写式日志（Write-ahead logging，缩写 WAL）通常包括redo和undo信息。根据数据重要级别，决定是否每次都将数据落盘。

#### 数据分布方式

hash 用户id的hash值 mod 服务器个数，缺点是扩展性差。一旦服务器个数变化，几乎所有数据需要被迁移并重新分布。可以增加中间层，即元数据服务器。需要防止数据倾斜问题。

还有两种，按数据范围分布和按数据量分布 。缺点都是元数据管理复杂。

一致性hash 通过引入虚节点的概念，虚节点的个数一般远大于未来集群中的机器数。首先根据数据的hash值找到虚节点，然后从元数据中找到真实节点。无论是增加节点还是节点宕机，都有助于实现全局负载均衡。

在存在多个副本的情况下，一般数据是以块的方式而不是机器的方式存放数据。这样便于在节点宕机后快速恢复数据以及负载均衡。

移动数据不如移动计算，本地化计算。

分库分表

wal vs redo 

数据分裂和合并。

### 分布式原理
### 一致性hash 
用于缓存和数据分区。 但是后者join 比较困难。 维护成本？

### 2阶段提交

两阶段提交：该协议通常用来实现分布式事务。系统一般包含两类节点：一类是协调者（coordinator），通常一个系统只有一个；另一类是事务参与者（participants），一般包含多个。协议中假设每个节点都会记录操作日志并持久化到非易失性存储介质。它分成两个阶段:
准备阶段：协调者通知事务参与者准备提交或者取消事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的的决策（同意还是取消）。
提交阶段：协调者根据第一个阶段的投票结果进行决策：提交还是取消。当且仅当所有参与者都统一提交事务，协调者才通知所有参与者提交事务，否则协调者通知所有参与者取消事务。参与者接收到协调者发送的消息后再执行相应的操作。

事务参与者发生故障 ：增加超时机制。
协调者发生故障：参考pdf分析文档。
3阶段提交 酷壳文章
超时+查询接口
csdn 改进
### lease
，相当于租金，zk
的session 时间。
### MVCC
则使用copy-on-write来解决这个问题

### PAXOS
画几张图

hostclass —》 host
 at least once，重发+唯一主键策略。
故障检测，Faliure  Detection

数据压缩 批处理
 

IOPS，即I/O per second，即每秒读写（I/O）操作的次数  http://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8A%A1%E5%86%85%E5%AD%98

事务内存目前有两种实现方式，基于软件的STM（Software Transactional Memory）和基于硬件的HTM（Hardware Transactional Memory）。 
 

单机 
多机
网络拓扑
协议定义
协议实现
google CLOS
 
 
 redo undo 定期刷新
存储 分为 大文件，小文件，结构化，非结构化，分布式文件存储和数据库存储。数据库存储 读写分离，垂直扩展（scale up） 分表，水平扩展（scale out）分库， 
  
数据分类：

* 非结构化数据：文本，图片，视频音频
* 结构化数据：数据模式（属性，数据类型，数据之间的联系）与内容是分开定义。
* 半结构化数据：模式和内容混在一起，没有明显的区分。
 
checkpoint 系统定期将内存的操作以某种易于加载的形式（checkpoint文件）转存到磁盘中，并记录checkpoint时刻的日志回放点，以后故障恢复只需要回放checkpoint时刻之后的redo日志。

行式存储 
列式存储
 
  
把发生故障当成常态来设计
配置统一管理
### 了解存储设备特性
### SATA
### SSD
### RAID
详细的介绍可以看这里
比RAID好多了”– 在一个非存储区域网络的RAID（non-SAN RAID）的建立中，磁盘是冗余的，但主机不是，如果你整个机器坏了，那么文件也将不能访问。 MogileFS分布式文件存储系统在不同的机器之间进行文件复制，因此文件始终是可用的。 主要是无法解决网络分区的问题。
### 分布式存储系统

分布式存储系统通常需要解决如下一些问题
* 数据分布  在多台服务器之间保证数据分布均匀，跨服务器如何读写
* 一致性  异常情况下如何保证副本一致性
* 容错  如何检测故障并进行故障迁移
* 负载均衡 新增、移除服务器时如何负载均衡 数据迁移如何不影响已有服务
* 事务并发控制  如何实现分布式事务，如何实现多版本并发控制
* 压缩、解压缩 根据数据特点选择恰当算法，如何平衡时间和空间的关系。


TDDL ， sql proxy、agent，binlog sync 分区分表 

存储    db,nosql,hbase, 分区表，字段压缩，查询优化，awr报告。

连接泄露原理是查询session视图，获得每个session的创建时间，看看那些session生命周期过长。然后找到对应执行的sql语句和业务代码。
#### 分布式文件系统
适合存储blob对象。
一个大文件分成多个数据块（chunk），每个数据块大小相当。分布式文件系统将这些数据块分散到存储机器，并将用户对数据的操作转化为对若干个数据块的操作。

#### 分布式键值系统
基于主键实现CRUD功能，通常使用一致性hash技术。

#### 分布式表格系统
不仅仅支持基于主键的CURD操作，还支持扫描某个主键范围。一般仅支持单表操作。通常存储半结构化数据，不需要预先定义模式。

#### 分布式数据库
二维表格组织数据，支持sql，多表关联，嵌套子查询等复杂操作，并支持并发数据库事务。
### 重要细节
同一个数据中心延时较小，网络一次来回的时间在1毫秒之内。北京，杭州距离1300km，光在信息传输时走折线，假设折现距离是直线距离的1.5倍，那么整个耗时 1300*1.5*2/300000=13毫秒，实测时40毫秒。 

分布式存储系统 p10 性能参数 
亚马逊中文论文 ，中间件ali blog
google系列论文

## 参考

* 《深入分析Java Web 技术内幕》
* 《大规模分布式存储系统原理解析与架构实战》
* 《大型网站技术架构核心原理与案例分析》
* 《分布式系统原理介绍》
* 《大规模Web服务开发技术》
* 《面向模式的软件架构_第4卷_分布式计算的模式语言》
* 《程序员》 2014 第一期
{% include JB/setup %}
