---
layout: post
title: "Java多线程编程"
description: "Java多线程编程"
category: 
tags: [J2SE]
---



# 基础篇
1. 简单锁示例,避免虚假唤醒,使用自旋锁,使等待的线程处于wait状态,等待被notify,而不是处于等待获得锁状态,非重入锁.

````	 
	public class Lock{
	private boolean isLocked = false;

	public synchronized void lock()
		throws InterruptedException{
		while(isLocked){
			wait();
		}
		isLocked = true;
	}

	public synchronized void unlock(){
		isLocked = false;
		notify();
	}
	}
````
	
2. 可重入锁示例,如果当前调用线程已经对该Lock实例加了锁，那么while循环就不会被执行.如果当前锁已经被加锁过多次。在unlock()调用没有达到对应lock()调用的次数之前，锁不会被解除

```
	public class Lock{
	boolean isLocked = false;
	Thread  lockedBy = null;
	int lockedCount = 0;

	public synchronized void lock()
		throws InterruptedException{
		Thread callingThread =
			Thread.currentThread();
		while(isLocked && lockedBy != callingThread){
			wait();
		}
		isLocked = true;
		lockedCount++;
		lockedBy = callingThread;
 	 }

	public synchronized void unlock(){
		if(Thread.curentThread() ==
			this.lockedBy){
			lockedCount--;

			if(lockedCount == 0){
				isLocked = false;
				notify();
			}
		}
	}

	
	}
```

1. 从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。
2.  多线程程序会额外增加CPU和内存的消耗,以及导致实现复杂.在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。在三种情况下可能会发生上下文切换：中断处理，多任务处理，用户态切换.线程还需要一些内存来维持它本地的堆栈,也需要占用操作系统中一些资源来管理线程.
3.  当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区.在临界区中使用适当的同步就可以避免竞态条件。
4.  “不变”（Immutable）和“只读”（Read Only）是不同的。当一个变量是“只读”时，变量的值不能直接改变，但是可以在其它变量发生改变的时候发生改变。比如，一个人的出生年月日是“不变”属性，而一个人的年龄便是“只读”属性，但是不是“不变”属性。随着时间的变化，一个人的年龄会随之发生变化，而一个人的出生年月日则不会变化。这就是“不变”和“只读”的区别。（摘自《Java与模式》第34章）
5.  Java 同步块（synchronized block）用来标记方法或者代码块是同步的。Java同步块用来避免竞争。实例方法同步,静态方法同步,实例方法中同步块,静态方法中同步块
6.  一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁.一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。
7.  为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。
8.  由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的(虚)假唤醒（spurious wakeups）.
7.  死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。
如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。但是需要注意,嵌套管程锁死时锁获取的顺序是一致的.嵌套管程锁死中，线程1持有锁A，同时等待从线程2发来的信号，线程2需要锁A来发信号给线程1。
8.  在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象。
9.  线程饥饿的原因:1.无CPU时间2.等待锁3.处于wait状态,无法被notify.有效避免饥饿的方法:1.使用Lock替换synchronized (这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。),并在finally中调用unlock方法2.使用公平锁(在前者的基础上,内部一般使用队列机制,然后从head中获取需要处理的元素) 
10. 可重入的意思是线程可以重复获得它已经持有的锁。Java的synchronized块是可重入的。 
11. 自旋锁:spinlock又称自旋锁，一般要求使用spinlock的临界区尽量简短，这样获取的锁可以尽快释放，以满足其他忙等的线程。Spinlock和mutex不同，spinlock不会导致线程的状态切换(用户态->内核态)，但是spinlock使用不当(如临界区执行时间过长)会导致cpu busy飙高。Spinlock优点：没有昂贵的系统调用，一直处于用户态，执行速度快
Spinlock缺点：一直占用cpu，而且在执行过程中还会锁bus总线，锁总线时其他处理器不能使用总线. Mutex优点：不会忙等，得不到锁会sleep. Mutex缺点：sleep时会陷入到内核态，需要昂贵的系统调用
12. 实现Runnable接口优于继承Thread覆写run方法.原因如下:1.避免Thread方法的干扰2.有着清晰的上下文 3. 可以继承其他类
13. 当一个线程正常地运行结束或者抛出某种未检测的异常（比如，运行时异常(RuntimeException)，错误(ERROR) 或者其子类）线程就会终止。当线程终止之后，是不能被重新启动的。在同一个Thread上调用多次start方法会抛出InvalidThreadStateException异常。
14. synchronized关键字并不是方法签名的一部分。所以当子类覆写父类中的同步方法或是接口中声明的同步方法的时候，synchronized修饰符是不会被自动继承的.
15. 调用wait方法会产生如下操作:如果当前线程已经终止，那么这个方法会立即退出并抛出一个InterruptedException异常。否则当前线程就进入阻塞状态。
Java虚拟机将该线程放置在目标对象的等待集合中。
释放目标对象的同步锁，但是除此之外的其他锁依然由该线程持有。即使是在目标对象上多次嵌套的同步调用，所持有的可重入锁也会完整的释放。这样，后面恢复的时候，当前的锁状态能够完全地恢复。
16. 调用Notify会产生如下操作：Java虚拟机从目标对象的等待集合中随意选择一个线程(称为T，前提是等待集合中还存在一个或多个线程)并从等待集合中移出T。当等待集合中存在多个线程时，并没有机制保证哪个线程会被选择到。线程T必须重新获得目标对象的锁，直到有线程调用notify释放该锁，否则线程会一直阻塞下去。如果其他线程先一步获得了该锁，那么线程T将继续进入阻塞状态。线程T从之前wait的点开始继续执行。
17. notifyAll方法与notify方法的运行机制是一样的，只是这些过程是在对象等待集合中的所有线程上发生（事实上，是同时发生）的。但是因为这些线程都需要获得同一个锁，最终也只能有一个线程继续执行下去。
18. 如果在一个因wait而中断的线程上调用Thread.interrupt方法，之后的处理机制和notify机制相同，只是在重新获取这个锁之后，该方法将会抛出一个InterruptedException异常并且线程的中断标识将被设为false。如果interrupt操作和一个notify操作在同一时间发生，那么不能保证那个操作先被执行，因此任何一个结果都是可能的。（JLS的未来版本可能会对这些操作结果提供确定性保证）
19. Timed Wait（定时等待）
定时版本的wait方法，wait(long mesecs)和wait(long msecs,int nanosecs),参数指定了需要在等待集合中等待的最大时间值。如果在时间限制之内没有被唤醒，它将自动释放，除此之外，其他的操作都和无参数的wait方法一样。并没有状态能够表明线程正常唤醒与超时唤醒之间的不同。需要注意的是，wait(0)与wait(0,0)方法其实都具有特殊的意义，其相当于不限时的wait()方法，这可能与你的直觉相反。
 

# JMM
## 序言
(摘自http://ifeve.com/syn-jmm-pre/,很不错,就没压缩了.)

	final class SetCheck {
		private int  a = 0;
		private long b = 0;
	
		void set() {
		a =  1;
		b = -1;
		}

		boolean check() {
		return ((b ==  0) ||
		(b == -1 && a == 1));
		}
	}


如果是在一个串行执行的语言中，执行SetCheck类中的check方法永远不会返回false，即使编译器，运行时和计算机硬件并没有按照你所期望的逻辑来处理这段程序，该方法依然不会返回false。在程序执行过程中，下面这些你所不能预料的行为都是可能发生的：

* 编译器可能会进行指令重排序，所以b变量的赋值操作可能先于a变量。如果是一个内联方法，编译器可能更甚一步将该方法的指令与其他语句进行重排序。
* 处理器可能会对语句所对应的机器指令进行重排序之后再执行，甚至并发地去执行。
 * 内存系统（由高速缓存控制单元组成）可能会对变量所对应的内存单元的写操作指令进行重排序。重排之后的写操作可能会对其他的计算/内存操作造成覆盖。

* 编译器，处理器以及内存系统可能会让两条语句的机器指令交错。比如在32位机器上，b变量的高位字节先被写入，然后是a变量，紧接着才会是b变量的低位字节。

* 编译器，处理器以及内存系统可能会导致代表两个变量的内存单元在（如果有的话）连续的check调用（如果有的话）之后的某个时刻才更新，而以这种方式保存相应的值（如在CPU寄存器中）仍会得到预期的结果（check永远不会返回false）。


每一个线程都可以被看作为运行在不同的CPU上，然而即使是在多处理器上，这种情况也是很罕见的。但是实际上，通过模型所具备的某些特性，这种CPU和线程单一映射能够通过一些合理的方法去实现。例如，因为CPU的寄存器不能被另一个CPU直接访问，这种模型必须考虑到某个线程无法得知被另一个线程操作变量的值的情况。这种情况不仅仅存在于多处理器环境上，在单核CPU环境里，因为编译器和处理器的不可预测的行为也可能导致同样的情况。

JMM为了解决如下三个相互牵连的问题：

* 原子性：哪些指令必须是不可分割的。在Java内存模型中，这些规则需声明仅适用于-—实例变量和静态变量，也包括数组元素，但不包括方法中的局部变量-—的内存单元的简单读写操作。
* 可见性：在哪些情况下，一个线程执行的结果对另一个线程是可见的。这里需要关心的结果有，写入的字段以及读取这个字段所看到的值。
* 有序性：在什么情况下，某个线程的操作结果对其它线程来看是无序的。最主要的乱序执行问题主要表现在读写操作和赋值语句的相互执行顺序上。

JMM将JVM内存分为工作内存和主内存.

当正确的使用了同步，上面属性都会具有一个简单的特性：一个同步方法或者代码块中所做的修改对于使用了同一个锁的同步方法或代码块都具有原子性和可见性。同步方法或代码块之间的执行过程都会和代码指定的执行顺序保持一致。即使代码块内部指令也许是乱序执行的，也不会对使用了同步的其它线程造成任何影响。

### 什么是内存模型
在多核系统中，处理器一般有一层或者多层的缓存，这些的缓存通过加速数据访问（因为数据距离处理器更近）和降低共享内存在总线上的通讯（因为本地缓存能够满足许多内存操作）来提高CPU性能。缓存能够大大提升性能，但是它们也带来了许多挑战。例如，当两个CPU同时检查相同的内存地址时会发生什么？在什么样的条件下它们会看到相同的值？


在处理器层面上，内存模型定义了一个充要条件，“让当前的处理器可以看到其他处理器写入到内存的数据”以及“其他处理器可以看到当前处理器写入到内存的数据”。

在较弱的内存模型的处理器中，必须使用内存屏障（一种特殊的指令）来刷新本地处理器缓存并使本地处理器缓存无效，目的是为了让当前处理器能够看到其他处理器的写操作或者让其他处理器能看到当前处理器的写操作。这些内存屏障通常在lock和unlock操作的时候完成。内存屏障在高级语言中对程序员是不可见的。

“一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致的。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后面会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到该操作的结果，这反映了缓存的影响。

此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其能在最佳顺序的情况下来执行操作。在内存模型的限定之内，我们能够获取到更高的性能。

在很多情况下，访问一个程序变量（对象实例字段，类静态字段和数组元素）可能会使用不同的顺序执行，而不是程序语义所指定的顺序执行。编译器能够自由的以优化的名义去改变指令顺序。在特定的环境下，处理器可能会次序颠倒的执行指令。数据可能在寄存器，处理器缓冲区和主内存中以不同的次序移动，而不是按照程序指定的顺序。

例如，如果一个线程写入值到字段a，然后写入值到字段b，而且b的值不依赖于a的值，那么，处理器就能够自由的调整它们的执行顺序，而且缓冲区能够在a之前刷新b的值到主内存。有许多潜在的重排序的来源，例如编译器，JIT以及缓冲区。 

编译器，运行时和硬件被期望一起协力创建好像是顺序执行的语义的假象，这意味着在单线程的程序中，程序应该是不能够观察到重排序的影响的。但是，重排序在没有正确同步了的多线程程序中开始起作用，在这些多线程程序中，一个线程能够观察到其他线程的影响，也可能检测到其他线程将会以一种不同于程序语义所规定的执行顺序来访问变量。

大部分情况下，一个线程不会关注其他线程正在做什么，但是当它需要关注的时候，这时候就需要同步了。

Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量“ 和 ”从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来正确实现以上事情。

Java包含了几个语言级别的关键字，包括：volatile, final以及synchronized，目的是为了帮助程序员向编译器描述一个程序的并发需求。Java内存模型定义了volatile和synchronized的行为，更重要的是保证了同步的java程序在所有的处理器架构下面都能正确的运行。

### 原子性
除了long型字段和double型字段外，java内存模型确保访问任意类型字段所对应的内存单元都是原子的。这包括引用其它对象的引用类型的字段。此外，volatile long 和volatile double也具有原子性 。（虽然java内存模型不保证non-volatile long 和 non-volatile double的原子性，当然它们在某些场合也具有原子性。）（译注：non-volatile long在64位JVM，OS，CPU下具有原子性）

当在一个表达式中使用一个non-long或者non-double型字段时，原子性可以确保你将获得这个字段的初始值或者某个线程对这个字段写入之后的值；但不会是两个或更多线程在同一时间对这个字段写入之后产生混乱的结果值（即原子性可以确保，获取到的结果值所对应的所有bit位，全部都是由单个线程写入的）。但是，原子性不能确保你获得的是任意线程写入之后的最新值。 

### 可见性
只有在下列情况时，一个线程对字段的修改才能确保对另一个线程可见：

一个写线程释放一个锁之后，另一个读线程随后获取了同一个锁。本质上，线程释放锁时会将强制刷新工作内存中的脏数据到主内存中，获取一个锁将强制线程装载（或重新装载）字段的值。锁提供对一个同步方法或块的互斥性执行，线程执行获取锁和释放锁时，所有对字段的访问的内存效果都是已定义的。

注意同步的双重含义：锁提供高级同步协议，同时在线程执行同步方法或块时，内存系统（有时通过内存屏障指令）保证值的一致性。这说明，与顺序程序设计相比较，并发程序设计与分布式程序设计更加类似。同步的第二个特性可以视为一种机制：一个线程在运行已同步方法时，它将发送和/或接收其他线程在同步方法中对变量所做的修改。从这一点来说，使用锁和发送消息仅仅是语法不同而已。


如果把一个字段声明为volatile型，线程对这个字段写入后，在执行后续的内存访问之前，线程必须刷新这个字段且让这个字段对其他线程可见（即该字段立即刷新）。每次对volatile字段的读访问，都要重新装载字段的值。

线程终止时，所有写过的变量值都要刷新到主内存中。注意，在同一个线程的不同方法之间传递对象的引用，永远也不会出现内存可见性问题。

内存模型确保上述操作最终会发生，一个线程对一个特定字段的特定更新，最终将会对其他线程可见，但这个“最终”可能是很长一段时间。线程之间没有同步时，很难保证对字段的值能在多线程之间保持一致（指写线程对字段的写入立即能对读线程可见）。特别是，如果字段不是volatile或没有通过同步来访问这个字段，在一个循环中等待其他线程对这个字段的写入，这种情况总是错误的

### 有序性

有序性规则表现在以下两种场景: 线程内和线程间

 从某个线程的角度看方法的执行，指令会按照一种叫“串行”（as-if-serial）的方式执行，此种方式已经应用于顺序编程语言。
 这个线程“观察”到其他线程并发地执行非同步的代码时，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块以及volatile字段的操作仍维持相对有序。

#关于voliate

从原子性，可见性和有序性的角度分析，声明为volatile字段的作用相当于一个类通过get/set同步方法保护普通字段，如下：
	
	final class VFloat {
    	private float value;

   		final synchronized void set(float f) 
   		{ value = f; }
   		 
   		final synchronized float get()       
    	{ return value; }
	}

 
与使用synchronized相比，声明一个volatile字段的区别在于没有涉及到锁操作。但特别的是对volatile字段进行“++”这样的读写操作不会被当做原子操作执行。

另外，有序性和可见性仅对volatile字段进行一次读取或更新操作起作用。声明一个引用变量为volatile，不能保证通过该引用变量访问到的非volatile变量的可见性。同理，声明一个数组变量为volatile不能确保数组内元素的可见性。volatile的特性不能在数组内传递，因为数组
里的元素不能被声明为volatile。


由于没有涉及到锁操作，声明volatile字段很可能比使用同步的开销更低，至少不会更高。但如果在方法内频繁访问volatile字段，很可能导致更低的性能，这时还不如锁住整个方法。

如果你不需要锁，把字段声明为volatile是不错的选择，但仍需要确保多线程对该字段的正确访问。可以使用volatile的情况包括：

该字段不遵循其他字段的不变式。
对字段的写操作不依赖于当前值。
没有线程违反预期的语义写入非法值。
读取操作不依赖于其它非volatile字段的值。
当只有一个线程可以修改字段的值，其它线程可以随时读取，那么把字段声明为volatile是合理的。例如，一个名叫Thermometer(中文：体温计)的类，可以声明temperature字段为volatile。正如在3.4.2节所讨论，一个volatile字段很适合作为完成某些工作的标志。另一个例子在4.4节有描述，通过使用轻量级的执行框架使某些同步工作自动化，但是仍需把结果字段声明为volatile，使其对各个任务都是可见的。

Volitile字段是用于线程间通讯的特殊字段。每次读volitile字段都会看到其它线程写入该字段的最新值；实际上，程序员之所以要定义volitile字段是因为在某些情况下由于缓存和重排序所看到的陈旧的变量值是不可接受的。编译器和运行时禁止在寄存器里面分配它们。它们还必须保证，在它们写好之后，它们被从缓冲区刷新到主存中，因此，它们立即能够对其他线程可见。相同地，在读取一个volatile字段之前，缓冲区必须失效，因为值是存在于主存中而不是本地处理器缓冲区。在重排序访问volatile变量的时候还有其他的限制。

在旧的内存模型下，访问volatile变量不能被重排序，但是，它们可能和访问非volatile变量一起被重排序。这破坏了volatile字段从一个线程到另外一个线程作为一个信号条件的手段。

在新的内存模型下，volatile变量仍然不能彼此重排序。和旧模型不同的时候，volatile周围的普通字段的也不再能够随便的重排序了。写入一个volatile字段和释放监视器有相同的内存影响，而且读取volatile字段和获取监视器也有相同的内存影响。事实上，因为新的内存模型在重排序volatile字段访问上面和其他字段（volatile或者非volatile）访问上面有了更严格的约束。当线程A写入一个volatile字段f的时候，如果线程B读取f的话 ，那么对线程A可见的任何东西都变得对线程B可见了。

如下例子展示了volatile字段应该如何使用：

	class VolatileExample {
  	int x = 0;
  	volatile boolean v = false;
  	public void writer() {
  	  x = 42;
    v = true;
  	}

  	public void reader() {
  	  if (v == true) {
  	    //uses x - guaranteed to see 42.
  	  }
 	 }
	}
	
假设一个线程叫做“writer”，另外一个线程叫做“reader”。对变量v的写操作会等到变量x写入到内存之后，然后读线程就可以看见v的值。因此，如果reader线程看到了v的值为true，那么，它也保证能够看到在之前发生的写入42这个操作。而这在旧的内存模型中却未必是这样的。如果v不是volatile变量，那么，编译器可以在writer线程中重排序写入操作，那么reader线程中的读取x变量的操作可能会看到0。

实际上，volatile的语义已经被加强了，已经快达到同步的级别了。为了可见性的原因，每次读取和写入一个volatile字段已经像一个半同步操作了








## 在Java内存模型这个语义环境下，我们谈到“没有正确同步”，我们的意思是：

一个线程中有一个对变量的写操作，
另外一个线程对同一个变量有读操作，
而且写操作和读操作没有通过同步来保证顺序。
当这些规则被违反的时候，我们就说在这个变量上有一个“数据竞争”(data race)。一个有数据竞争的程序就是一个没有正确同步的程序。

##同步会干些什么呢

同步有几个方面的作用。最广为人知的就是互斥 ——一次只有一个线程能够获得一个监视器，因此，在一个监视器上面同步意味着一旦一个线程进入到监视器保护的同步块中，其他的线程都不能进入到同一个监视器保护的块中间，除非第一个线程退出了同步块。


但是同步的含义比互斥更广。同步保证了一个线程在同步块之前或者在同步块中的一个内存写入操作以可预知的方式对其他有相同监视器的线程可见。当我们退出了同步块，我们就释放了这个监视器，这个监视器有刷新缓冲区到主内存的效果，因此该线程的写入操作能够为其他线程所见。在我们进入一个同步块之前，我们需要获取监视器，监视器有使本地处理器缓存失效的功能，因此变量会从主存重新加载，于是其它线程对共享变量的修改对当前线程来说就变得可见了。

依据缓存来讨论同步，可能听起来这些观点仅仅会影响到多处理器的系统。但是，重排序效果能够在单一处理器上面很容易见到。对编译器来说，在获取之前或者释放之后移动你的代码是不可能的。当我们谈到在缓冲区上面进行的获取和释放操作，我们使用了简述的方式来描述大量可能的影响。

新的内存模型语义在内存操作（读取字段，写入字段，锁，解锁）以及其他线程的操作（start 和 join）中创建了一个部分排序，在这些操作中，一些操作被称为happen before其他操作。当一个操作在另外一个操作之前发生，第一个操作保证能够排到前面并且对第二个操作可见。这些排序的规则如下：

线程中的每个操作happens before该线程中在程序顺序上后续的每个操作。
解锁一个监视器的操作happens before随后对相同监视器进行锁的操作。
对volatile字段的写操作happens before后续对相同volatile字段的读取操作。
线程上调用start()方法happens before这个线程启动后的任何操作。
一个线程中所有的操作都happens before从这个线程join()方法成功返回的任何其他线程。（注意思是其他线程等待一个线程的jion()方法完成，那么，这个线程中的所有操作happens before其他线程中的所有操作）
这意味着：任何内存操作，这个内存操作在退出一个同步块前对一个线程是可见的，对任何线程在它进入一个被相同的监视器保护的同步块后都是可见的，因为所有内存操作happens before释放监视器以及释放监视器happens before获取监视器。

其他如下模式的实现被一些人用来强迫实现一个内存屏障的，不会生效：

synchronized (new Object()) {}
这段代码其实不会执行任何操作，你的编译器会把它完全移除掉，因为编译器知道没有其他的线程会使用相同的监视器进行同步。要看到其他线程的结果，你必须为一个线程建立happens before关系。












临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。
当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界 区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界 区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。
from:http://ifeve.com/basic-thread-synchronization-1/

ThreadLocal.initialValue

InheritableThreadLocal 类提供线程创建线程的值的遗传性 。如果线程A有一个本地线程变量，然后它创建了另一个线程B，那么线程B将有与A相同的本地线程变量值。 你可以覆盖 childValue() 方法来初始子线程的本地线程变量的值。 它接收父线程的本地线程变量作为参数。

它是基于Lock接口和实现它的类（如ReentrantLock）。这种机制有如下优势：

它允许以一种更灵活的方式来构建synchronized块。使用synchronized关键字，你必须以结构化方式得到释放synchronized代码块的控制权。Lock接口允许你获得更复杂的结构来实现你的临界区。
Lock 接口比synchronized关键字提供更多额外的功能。新功能之一是实现的tryLock()方法。这种方法试图获取锁的控制权并且如果它不能获取该锁，是因为其他线程在使用这个锁，它将返回这个锁。使用synchronized关键字，当线程A试图执行synchronized代码块，如果线程B正在执行它，那么线程A将阻塞直到线程B执行完synchronized代码块。使用锁，你可以执行tryLock()方法，这个方法返回一个 Boolean值表示，是否有其他线程正在运行这个锁所保护的代码。
当有多个读者和一个写者时，Lock接口允许读写操作分离。
Lock接口比synchronized关键字提供更好的性能。

一个锁可能伴随着多个条件。这些条件声明在Condition接口中。 这些条件的目的是允许线程拥有锁的控制并且检查条件是否为true，如果是false，那么线程将被阻塞，直到其他线程唤醒它们。Condition接口提供一种机制，阻塞一个线程和唤醒一个被阻塞的线程。

所 有Condition对象都与锁有关，并且使用声明在Lock接口中的newCondition()方法来创建。使用condition做任何操作之前， 你必须获取与这个condition相关的锁的控制。所以，condition的操作一定是在以调用Lock对象的lock()方法为开头，以调用相同 Lock对象的unlock()方法为结尾的代码块中。

当一个线程在一个condition上调用await()方法时，它将自动释放锁的控制，所以其他线程可以获取这个锁的控制并开始执行相同操作，或者由同个锁保护的其他临界区。

注释：当一个线程在一个condition上调用signal()或signallAll()方法，一个或者全部在这个condition上等待的线程将被唤醒。这并不能保证的使它们现在睡眠的条件现在是true，所以你必须在while循环内部调用await()方法。你不能离开这个循环，直到 condition为true。当condition为false，你必须再次调用 await()方法。

你必须十分小心 ，在使用await()和signal()方法时。如果你在condition上调用await()方法而却没有在这个condition上调用signal()方法，这个线程将永远睡眠下去。

在调用await()方法后，一个线程可以被中断的，所以当它正在睡眠时，你必须处理InterruptedException异常。

--线程执行者
Executor-->ExecutorService-->AbstractExecutorService-->ThreadPoolExecutor
Executors 主要是ThreadPoolExecutor和
几种方法差别,线程池大小和队列不同.

当你想要取消你已提交给执行者的任务，使用Future接口的cancel()方法。根据cancel()方法参数和任务的状态不同，这个方法的行为将不同：

如果这个任务已经完成或之前的已被取消或由于其他原因不能被取消，那么这个方法将会返回false并且这个任务不会被取消。
如果这个任务正在等待执行者获取执行它的线程，那么这个任务将被取消而且不会开始它的执行。如果这个任务已经正在运行，则视方法的参数情况而定。 cancel()方法接收一个Boolean值参数。如果参数为true并且任务正在运行，那么这个任务将被取消。如果参数为false并且任务正在运行，那么这个任务将不会被取消。

如果你想要等待一个任务完成，你可以使用以下两种方法：

如果任务执行完成，Future接口的isDone()方法将返回true。
ThreadPoolExecutor类的awaitTermination()方法使线程进入睡眠，直到每一个任务调用shutdown()方法之后完成执行。
这两种方法都有一些缺点。第一个方法，你只能控制一个任务的完成。第二个方法，你必须等待一个线程来关闭执行者，否则这个方法的调用立即返回。


Java提供了你可以在你的并发程序中使用的，而且不会有任何问题或不一致的数据集合。基本上，Java提供两种在并发应用程序中使用的集合：

阻塞集合：这种集合包括添加和删除数据的操作。如果操作不能立即进行，是因为集合已满或者为空，该程序将被阻塞，直到操作可以进行。
非阻塞集合：这种集合也包括添加和删除数据的操作。如果操作不能立即进行，这个操作将返回null值或抛出异常，但该线程将不会阻塞。

阻塞 异步  http://www.zhihu.com/question/19732473
iteye帖子 
http://www.ibm.com/developerworks/cn/linux/l-async/


工作内
存 vs 主内存
后台线程作用
线程中断方法思考,为什么状态没被清除;join方法其实是对isAlive的方法封装.看下方法注释即可.
锁在对象头的表示
synchronized 本质上是互斥锁,而锁还有读写锁,公平锁,非公平锁等等.并且还可以通过cas实现lock-free.
惊群现象
不要使用stop等废弃方法 why? 共享变量(需要voliate?) 和中断状态
java client server 

那些坑
没指定线程name
没有限定线程个数
没指定默认队列大小
线程池是先指定core size,然后填满队列,最后再到max size.
惊群
死锁
ThreadLocal没有remove,没有static (线程池情况下)
组合的原子操作并不是线程安全的

	if(!vector.contains(element))
	   vector.add(element);  
这个"如果不存在那么添加"操作存在竞态条件,需要额外的锁机制 .	   
	    
线程非安全(voliate i++(Read-Modify-Write,每一个步骤计算的计算的结果依赖前一个步骤的状态),serverlet,spring 单例,服务无状态)while(wait)
实现putIfAbsent时,注意list的锁位置,不要使用不同的锁.CAS的ABBA

优化
锁粒度(没必要锁(虽然会优化),范围过大())
cmh的多个锁
伪共享(false sharing)
cas无阻塞,不会导致context switch
没有区分使用原子性,可见性和互斥性场景
通过缩小同步范围,并且并且应该尽量将不影响共享状态的操作从同步代码分离出去.

安全性是指"永远不发生糟糕的事情",活跃性是指"某件正确的事情最终会发生".

同步这个术语可以映射成几个关键字

* synchronized
  * 互斥锁,线程进入同步代码块前会自动获取锁,退出(包含正常,异常)代码块后会自动释放锁
* volatile
* 显式锁
* 原子变量

由3种方式可以修复因为多线程同步不当而导致的问题

* 不在线程之间贡献状态变量值
* 将状态变量修改为不可变的变量
* 在访问状态变量时使用同步

* 竞态条件的含义是说,当某个计算的正确性取决于多个线程的交替执行方式时,那么就会发生竞态条件.

* 重入
  * 当线程获取请求一个由其他线程获取的锁时,该线程会阻塞;当该线程获取一个由自己持有的锁时,如果这个请求会成功,我们称这个所是可以重入的.一般而言,重入锁的实现方法是:线程标识+锁的计数器

* 可见性
	*  在单线程环境中,如果向某个变量写入值后,并且没有其他写入操作下读取这个变量,那么总是能够获取相同的值.但是在多线程情况下,读线程和写线程并发执行时,W线程写入后,R线程不一定能够读到.为了确保多个线程之间对内存的写入操作的可见性,必须使用同步(因为同步机制保证了线程在退出同步代码块时,会刷新内存).
  
* JMM要求变量的读取和写入操作都必须时原子操作,但是对于非volatile类型的long和double变量,JVM允许将64位的读操作或写操作分解为2个32位的操作. 
* **加锁的含义不仅仅局限于互斥行为,还包括内存可见性**.为了确保所有线程都能看到共享变量的最新值,所有执行读和写操作的线程都必须在同一个锁上同步.
* volatile
	* 把变量声明为volatile类型后,编译器和运行时都会注意到这个变量是共享的,因此**不会将该变量上的操作和其他内存操作进行重排序**.volatile变量不会被缓存在寄存器或者处理器其他不可见的低分,因此在读取volatile类型的变量总是会返回最新写入的值
	* 对volatile的变量读写操作可以分别理解为synchronized get,set方法.但是区别是读写volatile变量不会执行加锁操作.所以说,volatile变量是一种比synchronized关键字更轻量级的一种同步.
	* volatile 变量通常用作表示某个操作完成,发生中断或者状态的标志;对volatile变量的写入操作应该不依赖当前volatile变量的值.
* 不可变对象
	* 不可变对象一定是安全的,它们只有一种状态.并且该状态由构造函数来控制. 	
* 设计线程安全类的三要素
	* 找出构成对象状态的所有要素(看类的属性)
	* 找出约束状态变量的不变性条件(状态之间的关联关系,比如P/C,队列满时不能放,队列空时不能取等)
	* 建立对象状态的并发访问管理策略 
* Iterable 
  * Collection
	* List
	* Set
	* Queue
		* BlockingQueue	
		  * LinkedBlockingQueue
		  * ArrayBlockingQueue
		  * PriorityBlockingQueue
	* Deque
* Map
  * SortedMap
  
* ConcurrentHashMap
	* 内部使用了分段锁机制(Lock Striping),这种机制允许任意数量的读取线程可以并发地访问Map,并且允许一定数量的线程可以并发地修改Map
	* CHM返回的迭代器具有弱一致性(Weakly Consistent),而并非"及时失败".弱一致性的迭代器可以容忍并发修改,并可以(但并不保证)在迭代器被构造后将修改操作反映给容器
	
* CopyOnWriteArrayList
  * 在每次修改时,都会创建并重新发布一个新的容器副本.
  * 适用于读多写少的场景,常用于监听器模式. 	
  
* 生产者/消费者
  * 类似于洗盘子.生产者把洗好的盘子放在盘架上,消费者把盘架上的盘子烘干.  
  
* Deque
  *  双端队列,支持在队列头和队列尾实现高速插入和移除
  
* 阻塞和中断
  * 阻塞原因
  	* 等待I/O操作结束
  	* 等待获得一个锁
  	* 等待从Thread.sleep方法中醒来
  	* 等待另外线程的计算结果
  * 阻塞状态
    * BLOCKED
    * WAITING
	* TIMED_WAITING
  * 阻塞和执行很长时间操作的区别
  	* 被阻塞的线程必须等待某个不受它控制的事件结束后才能继续执行.线程被置回RUNNABLE状态,并可以被继续调度执行
  * 中断异常
    * 当方法抛出InterruptedException,表明该方法可以被中断.当该方法被中断时,它将努力提前结束等待状态.
  	

# 参考
1. http://ifeve.com/ ,并发编程网
2. http://www.searchtb.com/2011/06/spinlock%E5%89%96%E6%9E%90%E4%B8%8E%E6%94%B9%E8%BF%9B.html
3. cas vs sync (只有这2种?) 
4. java 并发编程实践
{% include JB/setup %}
