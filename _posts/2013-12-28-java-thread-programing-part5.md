---
layout: post
title: "java thread programing part5 坑和优化"
description: ""
category: 
tags: []
---


那些坑
没指定线程name
没有限定线程个数
没指定默认队列大小
线程池是先指定core size,然后填满队列,最后再到max size.
惊群
stop不安全，其他被废弃的方法
死锁
ThreadLocal没有remove,没有static (线程池情况下)
组合的原子操作并不是线程安全的
惊群现象
不要使用stop等废弃方法 why? 共享变量(需要voliate?) 和中断状态
java client server
9.
  线程饥饿的原因:1.无CPU时间2.等待锁3.处于wait状态,无法被notify.有效避免饥饿的方法:1.使用Lock替换synchronized (这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。？？？),并在finally中调用unlock方法2.使用公平锁(在前者的基础上,内部一般使用队列机制,然后从head中获取需要处理的元素)

     if(!vector.contains(element))
        vector.add(element); 
这个"如果不存在那么添加"操作存在竞态条件,需要额外的锁机制 .       
        
线程非安全(voliate i++(Read-Modify-Write,每一个步骤计算的计算的结果依赖前一个步骤的状态),serverlet,spring 单例,服务无状态)
while(wait)
实现putIfAbsent时,注意list的锁位置,不要使用不同的锁.
CAS的ABA


优化
锁粒度(没必要锁(虽然会优化),范围过大())
cmh的多个锁
伪共享(false sharing)
cas无阻塞,不会导致context switch
没有区分使用原子性,可见性和互斥性场景
通过缩小同步范围,并且并且应该尽量将不影响共享状态的操作从同步代码分离出去.
 
5. 死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。
如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。但是需要注意,嵌套管程锁死时锁获取的顺序是一致的.嵌套管程锁死中，线程1持有锁A，同时等待从线程2发来的信号，线程2需要锁A来发信号给线程1。
  	
False Sharing
多线程要解决问题的本质：如何保证一个线程对对一个共享的资源的操作的结果，能够正确的反应到另一个线程对这个这个共享资源进行操作上来。

线程间通信

[safe construction ](http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html)
	 
原子服务的组合服务还原子吗

synchronized (new Object()) {}
这段代码其实不会执行任何操作，你的编译器会把它完全移除掉，因为编译器知道没有其他的线程会使用相同的监视器进行同步。要看到其他线程的结果，你必须为一个线程建立happens before关系。

临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。

在多个线程通信中，要注意以下几点：

1. 一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁.一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。
2. 为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。
3. 在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象。
4. 由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的(虚)假唤醒（spurious wakeups）.


而锁还有读写锁,公平锁,非公平锁等等

{% include JB/setup %}
